kernel void
init_kernel(global int * restrict in, int nels) {
	const int gi = get_global_id(0);

	if (gi >= nels) return;

	in[gi] = gi;
}

kernel void
reduce_v4(
	global int * restrict out,
	global const int4 * restrict in,
	int nquarts)
{
	const int gi = get_global_id(0);

	if (gi >= nquarts) return;

	const int4 val = in[gi];

	out[gi] = (val.x + val.y) + (val.z + val.w);
}

kernel void
reduce_lmem_double_barrier(
	global int * restrict out,
	global const int4 * restrict in,
	local int * lmem,
	int nquarts)
{
	const int gi = get_global_id(0);

	int acc = 0;

	if (gi < nquarts) {
		const int4 val = in[gi];
		acc = (val.x + val.y) + (val.z + val.w);
	}

	int li = get_local_id(0);

	int lws = get_local_size(0);
	while (lws > 1) {
		if (li < lws)
			lmem[li] = acc;
		barrier(CLK_LOCAL_MEM_FENCE);

		lws /= 2;

		if (li < lws)
			acc = lmem[2*li] + lmem[2*li + 1];
		barrier(CLK_LOCAL_MEM_FENCE);
	}

	if (li == 0)
		out[get_group_id(0)] = acc;
}

kernel void
reduce_lmem_interleaved(
	global int * restrict out,
	global const int4 * restrict in,
	local int * lmem,
	int nquarts)
{
	const int gi = get_global_id(0);

	int acc = 0;

	if (gi < nquarts) {
		const int4 val = in[gi];
		acc = (val.x + val.y) + (val.z + val.w);
	}

	int li = get_local_id(0);

	int offset = 1;
	const int lws = get_local_size(0);
	do {
		lmem[li] = acc;
		barrier(CLK_LOCAL_MEM_FENCE);
		if ((li & (2*offset - 1)) == 0) {
			acc += lmem[li + offset];
		}
		offset *= 2;
	} while (offset < lws);

	if (li == 0)
		out[get_group_id(0)] = acc;
}

kernel void
reduce_lmem(
	global int * restrict out,
	global const int4 * restrict in,
	local int * lmem,
	int nquarts)
{
	const int gi = get_global_id(0);

	int acc = 0;

	if (gi < nquarts) {
		const int4 val = in[gi];
		acc = (val.x + val.y) + (val.z + val.w);
	}

	int li = get_local_id(0);

	lmem[li] = acc;
	for (int lws = get_local_size(0)/2; lws >= 1; lws /=2 )
	{
		barrier(CLK_LOCAL_MEM_FENCE);
		if (li < lws) {
			acc += lmem[li + lws];
			lmem[li] = acc;
		}
	}

	if (li == 0)
		out[get_group_id(0)] = acc;
}

kernel void
reduce_lmem_wide(
	global int * restrict out,
	global const int4 * restrict in,
	local int * lmem,
	int nquarts)
{
	const int gi = get_global_id(0);
	const int gws = get_global_size(0);

	int acc = 0;

	int4 val0 = (int4)(0), val1 = (int4)(0), val2 = (int4)(0), val3 = (int4)(0);
	if (gi         < nquarts) val0 = in[gi];
	if (gi +   gws < nquarts) val1 = in[gi +   gws];
	if (gi + 2*gws < nquarts) val2 = in[gi + 2*gws];
	if (gi + 3*gws < nquarts) val3 = in[gi + 3*gws];

	int4 val = (val0 + val1) + (val2 + val3);
	acc = (val.x + val.y) + (val.z + val.w);

	int li = get_local_id(0);

	lmem[li] = acc;
	for (int lws = get_local_size(0)/2; lws >= 1; lws /=2 )
	{
		barrier(CLK_LOCAL_MEM_FENCE);
		if (li < lws) {
			acc += lmem[li + lws];
			lmem[li] = acc;
		}
	}

	if (li == 0)
		out[get_group_id(0)] = acc;
}

kernel void
reduce_lmem_sliding_window(
	global int * restrict out,
	global const int4 * restrict in,
	local int * lmem,
	int nquarts)
{
	int gi = get_global_id(0);
	const int gws = get_global_size(0);

	int acc = 0;

	while (gi < nquarts) {
		int4 val0 = (int4)(0), val1 = (int4)(0), val2 = (int4)(0), val3 = (int4)(0);
		if (gi         < nquarts) val0 = in[gi];
		if (gi +   gws < nquarts) val1 = in[gi +   gws];
		if (gi + 2*gws < nquarts) val2 = in[gi + 2*gws];
		if (gi + 3*gws < nquarts) val3 = in[gi + 3*gws];

		int4 val = (val0 + val1) + (val2 + val3);
		acc += (val.x + val.y) + (val.z + val.w);

		gi += 4*gws;
	}

	int li = get_local_id(0);

	lmem[li] = acc;
	for (int lws = get_local_size(0)/2; lws >= 1; lws /=2 )
	{
		barrier(CLK_LOCAL_MEM_FENCE);
		if (li < lws) {
			acc += lmem[li + lws];
			lmem[li] = acc;
		}
	}

	if (li == 0)
		out[get_group_id(0)] = acc;
}
